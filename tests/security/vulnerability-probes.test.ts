/**
 * Vulnerability Probe Tests
 *
 * These tests are designed to FIND vulnerabilities, not just validate existing defenses.
 * Tests that FAIL here indicate a security issue that needs fixing.
 *
 * If a test passes when it should fail, that's a vulnerability found!
 */

import * as os from 'os'
import * as path from 'path'
import * as fs from 'fs'
import { promises as fsPromises } from 'fs'
import type { IpcMainInvokeEvent, WebContents, WebFrameMain } from 'electron'

// Store the real temp dir (with symlinks resolved)
const REAL_TEMP_DIR = fs.realpathSync(os.tmpdir())

// Captured handlers
const handlers = new Map<string, Function>()

// Mock Electron modules
jest.mock('electron', () => {
  const actualPath = jest.requireActual('path')
  const actualOs = jest.requireActual('os')
  const actualFs = jest.requireActual('fs')
  const realTempDir = actualFs.realpathSync(actualOs.tmpdir())

  return {
    app: {
      getPath: jest.fn((name: string) => {
        const paths: Record<string, string> = {
          userData: actualPath.join(realTempDir, 'bokeh-vuln-test-userData'),
          temp: realTempDir,
          downloads: actualPath.join(realTempDir, 'bokeh-vuln-test-downloads'),
          documents: actualPath.join(realTempDir, 'bokeh-vuln-test-documents'),
        }
        return paths[name] || actualPath.join(realTempDir, `bokeh-vuln-test-${name}`)
      }),
      getAppPath: jest.fn(() => actualPath.join(realTempDir, 'bokeh-vuln-test-app')),
      isPackaged: false,
      on: jest.fn(),
    },
    ipcMain: {
      handle: jest.fn((channel: string, handler: Function) => {
        handlers.set(channel, handler)
      }),
      removeHandler: jest.fn(),
    },
    nativeImage: {
      createFromPath: jest.fn(() => ({ isEmpty: () => true })),
      createFromBuffer: jest.fn(() => ({ isEmpty: () => true })),
    },
  }
})

jest.mock('../../electron/main/services/proxy-service', () => ({
  ensurePreviewProxy: jest.fn(),
  ensureGlowProxy: jest.fn(),
  needsPreviewProxy: jest.fn(),
  getExistingProxyPath: jest.fn(),
  getExistingGlowProxyPath: jest.fn(),
  clearPreviewProxies: jest.fn(),
  clearGlowProxies: jest.fn(),
  getProxyCacheSize: jest.fn(() => 0),
  getVideoDimensions: jest.fn(),
  getVideoMetadata: jest.fn(),
  generateThumbnail: jest.fn(),
}))

jest.mock('../../electron/main/utils/video-url-factory', () => ({
  makeVideoSrc: jest.fn((p: string) => `video-stream://${p}`),
}))

jest.mock('../../electron/main/utils/file-resolution', () => ({
  resolveRecordingFilePath: jest.fn(() => null),
}))

function createMockEvent(senderUrl: string = 'app://./index.html'): IpcMainInvokeEvent {
  return {
    sender: {
      id: 1,
      getURL: () => senderUrl,
      send: jest.fn(),
    } as unknown as WebContents,
    senderFrame: { url: senderUrl } as unknown as WebFrameMain,
    frameId: 1,
    processId: 1,
    defaultPrevented: false,
    preventDefault: jest.fn(),
  } as unknown as IpcMainInvokeEvent
}

async function callHandler(channel: string, event: IpcMainInvokeEvent, ...args: any[]): Promise<any> {
  const handler = handlers.get(channel)
  if (!handler) throw new Error(`Handler not found: ${channel}`)
  try {
    return await handler(event, ...args)
  } catch (error) {
    return { success: false, error: error instanceof Error ? error.message : String(error) }
  }
}

describe('Vulnerability Probes', () => {
  beforeAll(async () => {
    handlers.clear()
    const { registerFileOperationHandlers } = await import('../../electron/main/ipc/file-operations')
    const { registerRecordingHandlers } = await import('../../electron/main/ipc/recording')
    const { registerWallpaperHandlers } = await import('../../electron/main/ipc/wallpapers')
    registerFileOperationHandlers()
    registerRecordingHandlers()
    registerWallpaperHandlers()
  })

  // ===========================================================================
  // VULNERABILITY PROBE 1: app:// protocol hostname bypass
  // The isTrustedRendererUrl function trusts ANY app:// URL without checking hostname
  // ===========================================================================
  describe('VULN-001: app:// protocol hostname not validated', () => {
    it('should block app://evil.com (FAILS if vulnerable)', async () => {
      // If this test PASSES, it means app://evil.com is blocked (good)
      // If this test FAILS, we found a vulnerability!
      const event = createMockEvent('app://evil.com/malicious.html')
      const result = await callHandler('read-local-file', event, REAL_TEMP_DIR)

      // We EXPECT this to be blocked
      expect(result.success).toBe(false)
      expect(result.error).toMatch(/blocked|untrusted|denied/i)
    })

    it('should block app://localhost.evil.com', async () => {
      const event = createMockEvent('app://localhost.evil.com/index.html')
      const result = await callHandler('read-local-file', event, REAL_TEMP_DIR)

      expect(result.success).toBe(false)
      expect(result.error).toMatch(/blocked|untrusted|denied/i)
    })

    it('should block app://127.0.0.1.evil.com', async () => {
      const event = createMockEvent('app://127.0.0.1.evil.com/index.html')
      const result = await callHandler('read-local-file', event, REAL_TEMP_DIR)

      expect(result.success).toBe(false)
      expect(result.error).toMatch(/blocked|untrusted|denied/i)
    })
  })

  // ===========================================================================
  // VULNERABILITY PROBE 2: Null byte injection in paths
  // Null bytes can truncate strings in some contexts
  // ===========================================================================
  describe('VULN-002: Null byte injection', () => {
    it('should block null byte in path: /tmp/safe.txt\\x00/../../../etc/passwd', async () => {
      const event = createMockEvent('app://./index.html')
      const maliciousPath = `${REAL_TEMP_DIR}/safe.txt\x00/../../../etc/passwd`
      const result = await callHandler('read-local-file', event, maliciousPath)

      expect(result.success).toBe(false)
    })

    it('should block null byte before extension', async () => {
      const event = createMockEvent('app://./index.html')
      const maliciousPath = `${REAL_TEMP_DIR}/file\x00.txt`
      const result = await callHandler('save-recording', event, maliciousPath, Buffer.from('test'))

      // Should either fail or the file should NOT exist at the truncated path
      if (result.success) {
        // If it "succeeded", check if the file was created without the null byte
        const truncatedPath = `${REAL_TEMP_DIR}/file`
        const exists = fs.existsSync(truncatedPath)
        expect(exists).toBe(false) // Should NOT exist at truncated path
      }
    })
  })

  // ===========================================================================
  // VULNERABILITY PROBE 3: Unicode normalization attacks
  // ===========================================================================
  describe('VULN-003: Unicode normalization', () => {
    it('should handle unicode path traversal: ../\\u002e\\u002e/', async () => {
      const event = createMockEvent('app://./index.html')
      // \u002e is the unicode for '.'
      const maliciousPath = `${REAL_TEMP_DIR}/\u002e\u002e/\u002e\u002e/etc/passwd`
      const result = await callHandler('read-local-file', event, maliciousPath)

      expect(result.success).toBe(false)
      expect(result.error).toMatch(/access denied/i)
    })

    it('should handle fullwidth characters: ．．／ (fullwidth dots and slash)', async () => {
      const event = createMockEvent('app://./index.html')
      // Fullwidth characters that might normalize to ASCII equivalents
      const maliciousPath = `${REAL_TEMP_DIR}/\uFF0E\uFF0E\uFF0Fetc/passwd` // ．．／
      const result = await callHandler('read-local-file', event, maliciousPath)

      expect(result.success).toBe(false)
    })
  })

  // ===========================================================================
  // VULNERABILITY PROBE 4: Double encoding / URL encoding in paths
  // ===========================================================================
  describe('VULN-004: Encoded path traversal', () => {
    it('should block percent-encoded traversal: %2e%2e%2f', async () => {
      const event = createMockEvent('app://./index.html')
      // %2e = '.', %2f = '/'
      const maliciousPath = `${REAL_TEMP_DIR}/%2e%2e/%2e%2e/etc/passwd`
      const result = await callHandler('read-local-file', event, maliciousPath)

      // Path.resolve might not decode these, so this might "fail" by file not found
      // But it should NOT succeed in reading /etc/passwd
      if (result.success && result.data) {
        const content = Buffer.from(result.data).toString()
        expect(content).not.toContain('root:')
      }
    })

    it('should block double-encoded traversal: %252e%252e%252f', async () => {
      const event = createMockEvent('app://./index.html')
      const maliciousPath = `${REAL_TEMP_DIR}/%252e%252e/%252e%252e/etc/passwd`
      const result = await callHandler('read-local-file', event, maliciousPath)

      if (result.success && result.data) {
        const content = Buffer.from(result.data).toString()
        expect(content).not.toContain('root:')
      }
    })
  })

  // ===========================================================================
  // VULNERABILITY PROBE 5: Case sensitivity bypass (macOS is case-insensitive)
  // ===========================================================================
  describe('VULN-005: Case sensitivity bypass', () => {
    it('should handle /ETC/PASSWD on case-insensitive filesystems', async () => {
      const event = createMockEvent('app://./index.html')
      const result = await callHandler('read-local-file', event, '/ETC/PASSWD')

      expect(result.success).toBe(false)
      expect(result.error).toMatch(/access denied/i)
    })

    it('should handle mixed case traversal: ../ETC/../etc/passwd', async () => {
      const event = createMockEvent('app://./index.html')
      const maliciousPath = `${REAL_TEMP_DIR}/../ETC/../etc/passwd`
      const result = await callHandler('read-local-file', event, maliciousPath)

      expect(result.success).toBe(false)
    })
  })

  // ===========================================================================
  // VULNERABILITY PROBE 6: Double slash path confusion
  // ===========================================================================
  describe('VULN-006: Double slash path confusion', () => {
    it('should handle //etc/passwd', async () => {
      const event = createMockEvent('app://./index.html')
      const result = await callHandler('read-local-file', event, '//etc/passwd')

      expect(result.success).toBe(false)
    })

    it('should handle /tmp//../../etc/passwd', async () => {
      const event = createMockEvent('app://./index.html')
      const result = await callHandler('read-local-file', event, `${REAL_TEMP_DIR}//../../etc/passwd`)

      expect(result.success).toBe(false)
    })

    it('should handle paths with multiple slashes: /tmp////file', async () => {
      const event = createMockEvent('app://./index.html')
      const result = await callHandler('read-local-file', event, `${REAL_TEMP_DIR}////../../etc/passwd`)

      expect(result.success).toBe(false)
    })
  })

  // ===========================================================================
  // VULNERABILITY PROBE 7: Symlink TOCTOU (Time-of-Check-Time-of-Use)
  // ===========================================================================
  describe('VULN-007: Symlink TOCTOU race condition', () => {
    const testDir = path.join(REAL_TEMP_DIR, 'toctou-test')
    const linkPath = path.join(testDir, 'link')
    const safePath = path.join(testDir, 'safe')

    beforeAll(async () => {
      await fsPromises.mkdir(testDir, { recursive: true })
      await fsPromises.mkdir(safePath, { recursive: true })
      await fsPromises.writeFile(path.join(safePath, 'file.txt'), 'safe content')
    })

    afterAll(async () => {
      await fsPromises.rm(testDir, { recursive: true, force: true }).catch(() => {})
    })

    it('documents TOCTOU risk: symlink changed after validation', async () => {
      // This test documents that a TOCTOU attack is theoretically possible
      // In practice, the window is very small

      // Step 1: Create a safe symlink
      const safeTarget = path.join(safePath, 'file.txt')
      try { await fsPromises.unlink(linkPath) } catch {}
      await fsPromises.symlink(safeTarget, linkPath)

      // Step 2: Start the read operation (validation happens)
      const event = createMockEvent('app://./index.html')

      // In a real TOCTOU attack, between validation and read:
      // - Attacker removes the symlink
      // - Attacker creates new symlink pointing to /etc/passwd

      // For this test, we just verify the current implementation
      // uses realpathSync which is atomic for the check
      const result = await callHandler('read-local-file', event, linkPath)

      // The read should work for the safe file
      // (This test mainly documents the risk - actual TOCTOU is timing-dependent)
      expect(result.success).toBe(true)
    })
  })

  // ===========================================================================
  // VULNERABILITY PROBE 8: Type confusion attacks
  // ===========================================================================
  describe('VULN-008: Type confusion', () => {
    it('should handle array instead of string path', async () => {
      const event = createMockEvent('app://./index.html')
      const maliciousPath = ['/etc/passwd', '/etc/shadow'] as any
      const result = await callHandler('read-local-file', event, maliciousPath)

      // Should fail or not return sensitive data
      expect(result.success).toBe(false)
    })

    it('should handle object instead of string path', async () => {
      const event = createMockEvent('app://./index.html')
      const maliciousPath = { toString: () => '/etc/passwd' } as any
      const result = await callHandler('read-local-file', event, maliciousPath)

      // If it converted to string via toString(), it might read /etc/passwd
      if (result.success && result.data) {
        const content = Buffer.from(result.data).toString()
        expect(content).not.toContain('root:')
      }
    })

    it('should handle number instead of string path', async () => {
      const event = createMockEvent('app://./index.html')
      const result = await callHandler('read-local-file', event, 12345 as any)

      expect(result.success).toBe(false)
    })

    it('should handle prototype pollution attempt', async () => {
      const event = createMockEvent('app://./index.html')
      const maliciousPath = JSON.parse('{"__proto__": {"polluted": true}}')
      const result = await callHandler('read-local-file', event, maliciousPath)

      expect(result.success).toBe(false)
      // Verify no prototype pollution
      expect(({} as any).polluted).toBeUndefined()
    })
  })

  // ===========================================================================
  // VULNERABILITY PROBE 9: Integer overflow in size limits
  // ===========================================================================
  describe('VULN-009: Integer overflow in size checks', () => {
    it('should handle negative file size', async () => {
      // The 10MB limit check might be bypassed with negative numbers
      // This is more of a documentation test since we can't easily
      // create a file that reports negative size
      const MAX_SIZE = 10 * 1024 * 1024
      const maliciousSize = -1

      // A vulnerable check: if (size > MAX_SIZE) reject
      // With negative size, -1 > 10MB is false, so it passes!
      expect(maliciousSize > MAX_SIZE).toBe(false) // Shows the vulnerability pattern
    })
  })

  // ===========================================================================
  // VULNERABILITY PROBE 10: Metadata file name regex bypass
  // ===========================================================================
  describe('VULN-010: Metadata filename regex bypass', () => {
    it('should block metadata files with extra characters', async () => {
      const event = createMockEvent('app://./index.html')
      // Try to add characters before the expected pattern
      const maliciousPath = path.join(
        REAL_TEMP_DIR,
        'xmetadata-aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee.json'
      )
      const result = await callHandler('read-metadata-file', event, maliciousPath)

      expect(result.success).toBe(false)
    })

    it('should block path traversal in metadata filename', async () => {
      const event = createMockEvent('app://./index.html')
      // Try to put traversal in the "UUID" part
      const maliciousPath = path.join(
        REAL_TEMP_DIR,
        'metadata-/../../../etc/passwd-.json'
      )
      const result = await callHandler('read-metadata-file', event, maliciousPath)

      expect(result.success).toBe(false)
    })

    it('should block metadata file outside temp via symlink in temp', async () => {
      const symlinkDir = path.join(REAL_TEMP_DIR, 'metadata-link')
      const targetOutside = '/etc'

      try {
        await fsPromises.symlink(targetOutside, symlinkDir)
      } catch {
        return // Can't create symlink, skip test
      }

      try {
        const event = createMockEvent('app://./index.html')
        const maliciousPath = path.join(
          symlinkDir,
          'metadata-aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee.json'
        )
        const result = await callHandler('read-metadata-file', event, maliciousPath)

        expect(result.success).toBe(false)
      } finally {
        await fsPromises.unlink(symlinkDir).catch(() => {})
      }
    })
  })

  // ===========================================================================
  // VULNERABILITY PROBE 11: Wallpaper path restrictions
  // ===========================================================================
  describe('VULN-011: Wallpaper directory escape', () => {
    it('should block /System/Library/Desktop Pictures/../../../etc/passwd', async () => {
      const event = createMockEvent('app://./index.html')
      const maliciousPath = '/System/Library/Desktop Pictures/../../../etc/passwd'
      const result = await callHandler('load-wallpaper-image', event, maliciousPath)

      expect(result.success).toBe(false)
    })

    it('should block case variation: /SYSTEM/Library/Desktop Pictures/file.heic', async () => {
      const event = createMockEvent('app://./index.html')
      // macOS is case-insensitive, so /SYSTEM equals /System
      // But we want to ensure the validation is also case-insensitive
      const result = await callHandler(
        'load-wallpaper-image',
        event,
        '/SYSTEM/LIBRARY/Desktop Pictures/../../../etc/passwd'
      )

      expect(result.success).toBe(false)
    })
  })

  // ===========================================================================
  // VULNERABILITY PROBE 12: Empty/undefined sender checks
  // ===========================================================================
  describe('VULN-012: Missing/malformed sender information', () => {
    it('should block when senderFrame.url is undefined', async () => {
      const event = {
        sender: {
          id: 1,
          getURL: () => undefined as any,
          send: jest.fn(),
        },
        senderFrame: { url: undefined },
      } as unknown as IpcMainInvokeEvent

      const result = await callHandler('read-local-file', event, REAL_TEMP_DIR)
      expect(result.success).toBe(false)
    })

    it('should block when sender.getURL returns empty string', async () => {
      const event = {
        sender: {
          id: 1,
          getURL: () => '',
          send: jest.fn(),
        },
        senderFrame: { url: '' },
      } as unknown as IpcMainInvokeEvent

      const result = await callHandler('read-local-file', event, REAL_TEMP_DIR)
      expect(result.success).toBe(false)
    })
  })

  // ===========================================================================
  // VULNERABILITY PROBE 13: Very long paths (buffer overflow potential)
  // ===========================================================================
  describe('VULN-013: Path length attacks', () => {
    it('should handle extremely long path (10KB)', async () => {
      const event = createMockEvent('app://./index.html')
      const longComponent = 'a'.repeat(10000)
      const maliciousPath = `${REAL_TEMP_DIR}/${longComponent}`
      const result = await callHandler('read-local-file', event, maliciousPath)

      // Should fail gracefully, not crash
      expect(result.success).toBe(false)
    })

    it('should handle path with many directory components', async () => {
      const event = createMockEvent('app://./index.html')
      const manyDirs = Array(1000).fill('dir').join('/')
      const maliciousPath = `${REAL_TEMP_DIR}/${manyDirs}/file.txt`
      const result = await callHandler('read-local-file', event, maliciousPath)

      // Should fail gracefully
      expect(result.success).toBe(false)
    })
  })
})

// ===========================================================================
// Direct isPathWithin() function probes
// ===========================================================================
describe('isPathWithin() Direct Probes', () => {
  let isPathWithin: (candidate: string, base: string) => boolean

  beforeAll(async () => {
    const mod = await import('../../electron/main/utils/path-validation')
    isPathWithin = mod.isPathWithin
  })

  it('should return false for base === candidate (empty relative path)', () => {
    // When candidate equals base, relative path is '', which is falsy
    // This means you can't access the base directory itself
    const result = isPathWithin('/tmp', '/tmp')
    expect(result).toBe(false) // Documents current behavior
  })

  it('should handle trailing slashes consistently', () => {
    const result1 = isPathWithin('/tmp/file', '/tmp')
    const result2 = isPathWithin('/tmp/file', '/tmp/')

    // Both should behave the same
    expect(result1).toBe(result2)
  })

  it('should reject candidate that is parent of base', () => {
    const result = isPathWithin('/tmp', '/tmp/subdir')
    expect(result).toBe(false)
  })
})

// ===========================================================================
// isTrustedRendererUrl() Direct Probes
// ===========================================================================
describe('isTrustedRendererUrl() Direct Probes', () => {
  let isTrustedRendererUrl: (url: string) => boolean

  beforeAll(async () => {
    const mod = await import('../../electron/main/utils/ipc-security')
    isTrustedRendererUrl = mod.isTrustedRendererUrl
  })

  it('CRITICAL: should NOT trust app://evil.com', () => {
    // This is the key vulnerability test!
    // If this passes, the app:// protocol properly validates hostnames
    // If this fails, ANY app:// URL is trusted (VULNERABILITY!)
    const result = isTrustedRendererUrl('app://evil.com/malicious')
    expect(result).toBe(false)
  })

  it('CRITICAL: should NOT trust app://attacker.com', () => {
    const result = isTrustedRendererUrl('app://attacker.com/steal-data')
    expect(result).toBe(false)
  })

  it('should trust app://. (current origin)', () => {
    const result = isTrustedRendererUrl('app://./index.html')
    expect(result).toBe(true)
  })

  it('should handle app:// with no host', () => {
    const result = isTrustedRendererUrl('app:///index.html')
    // Behavior depends on implementation - document it
    console.log('app:///index.html trusted:', result)
  })

  it('should reject javascript: URLs', () => {
    const result = isTrustedRendererUrl('javascript:alert(1)')
    expect(result).toBe(false)
  })

  it('should reject data: URLs', () => {
    const result = isTrustedRendererUrl('data:text/html,<script>alert(1)</script>')
    expect(result).toBe(false)
  })

  it('should reject blob: URLs', () => {
    const result = isTrustedRendererUrl('blob:app://./some-id')
    expect(result).toBe(false)
  })
})
